--------------------Premier pas-------
    -- On  peut faire aussi comme �a:
	Import-Module SQLSERVER
        CD SQLSERVER:\sql\localhost\DEFAULT


    --Ces SnapIn doit exister si je veux utiliser SQLSERVER sur PowerShell
        Get-PSSnapin SqlServerCmdLetSnapin100
        Get-PSSnapin SqlServerProviderSnapin100
    --Sinon il faut les ajouter   (sur 2012 pas besoin de �a, on doit  charger SQLPS)
        Add-PSSnapin SqlServerCmdLetSnapin100
        Add-PSSnapin SqlServerProviderSnapin100

---------------------------------------

    --Se placer dans le serveur SQL
        Set-Location SQLSERVER:\SQL\localhost

    --Requ�te
        Invoke-Sqlcmd -Query "SELECT DB_NAME() as [Database]"

    --Requ�te T-SQL
        CD SQLSERVER:\sql\localhost\DEFAULT
        Invoke-sqlcmd -Database TV_ATOFFICE -Query "select * from USR" | Format-Table

    --Requ�te T-SQL - Sortie CSV
        CD SQLSERVER:\sql\localhost\DEFAULT
        Invoke-sqlcmd -Database TV_ATOFFICE -Query "select * from USR" | Export-CSV c:\TV_USER.csv  -encoding "unicode"

    --Cr�er dossier
        md c:\test
    --cr�er fichier
        fsutil file createnew C:\test\mynewfile.txt 1000

    --Divers stats du serveur envoy�es dans un fichier
        ipconfig /all >C:\test\tshoot.txt
        route print >C:\test\tshoot.txt
        hostname >C:\test\tshoot.txt
        net statistics workstation >C:\test\tshoot.txt
    --Ouverture fichier texte
        notepad C:\test\tshoot.txt
    --Passer le noms de tables d'une base de donn�es dans un fichier texte
      --Lancer PowerShell en cliquant droit sur une Base de donn�es (SSMS)
        dir -Name >C:\test\TableNes.txt







-----------------------------------------------

#https://www.mssqltips.com/sqlservertip/1745/using-powershell-with-sql-server-management-objects-smo/
--recuperer des scripts : https://github.com/MikeFal

--PLusieurs lignes de commentaires
<#
#>

--Voir les Provider � disposition (on doit voir SQLServer apparaitre dans la liste
Get-PSProvider

--Voir les DRIVE (connecteurs disque c:\ d:\)
Get-PSDrive

--Voir les enfants du provider dans lequel on est
Get-ChildItem

--Si Dans Get-PSDrive: SQLSERVER apparait alors je peux naviguer dans SQL Server
  -- Si je fait "dir" ici alors j'ai tout le parametrage de mon serveur
SQLSERVER:\SQL\DELLV-SD\Default

--Ces SnapIn doit exister si je veux utiliser SQLSERVER sur PowerShell
Get-PSSnapin SqlServerCmdLetSnapin100
Get-PSSnapin SqlServerProviderSnapin100
--Sinon il faut les ajouter   (sur 2012 pas besoin de �a, on doit  charger SQLPS)
Add-PSSnapin SqlServerCmdLetSnapin100
Add-PSSnapin SqlServerProviderSnapin100

--Utiliser les commandes relatives au module SQL Server
Get-Command �Module *SQL*
Get-Command �Name *SQL*

--Voir les propri�t�s d'un objet � partir de son type
$message = "Hello World!"
$message | Get-Member

--Il existe une variable systeme pour Powershell: PSModulePath
$env:PSModulePath


--Version de PowerShell
$PSVersionTable

--Changer de version
Powershell.exe -Version 2

--Liste des CmdLet avec le mot Log
Get-Command -Name "*Log*"

--Help (aide) sur un CmdLet
Get-Help Get-Service

--Exemples
get-help Get-Service -examples

--Simple requ�te
sqlcmd -S localhost -d TV_ATOFFICE -U sa -P admin -Q "select getDate()"
Invoke-Sqlcmd -ServerInstance localhost -Database TV_ATOFFICE -Query "select GetDate()"

--Lecteur sur le PC
Get-PSDrive

--Allez voir dans le registre les infos li�es � Sql Server
cd "HKLM:\Software\Microsoft\Microsoft SQl Server"

--Afficher tous les cmdlet qui commence par Get-
Get-Command | Where-Object {$_.Name -like "Get-*"}

--Affiche les cmdlet qui commence par Format-
Get-Command Format-*

--Affiche les service qui concomme plus de 50 Mb sur le PC en les formatant sous forme de liste
Get-Process | Where-Object {$_.PrivateMemorySize -gt 50MB} | SELECT ProcessName, PrivateMemorySize, CPU | Format-List

--Exporter sur fichier CSV les servies qui consomme pmlus de 50 Mb sur le PC
Get-Process | Where-Object {$_.PrivateMemorySize -gt 50MB} | SELECT ProcessName, PrivateMemorySize, CPU | Export-CSV c:\process.csv

--Membres du cmdlet Get-Command
Get-Command | Get-Member

--Executer .ps1 - cganger la politiique de s�curit� pour cela
Set-executionPolicy RemoteSigned

--Redemaret le service SQL Server san connaitre le nom de l'instance complete
Get-Service | Where-Object {$_.Name -like "MSSQL$*"} | ReStart-Service -Force

--Service qui consome plus de 50 Mb sur le PC (gt->Greater Than, lt->Less Than, le->Less or Equal)
Get-Process | Where-Object {$_.PrivateMemorySize -gt 50MB}

--Se deplacer dansles dossier
Set-Location SQLSERVER:\SQL\localhost

--Ecrire sur l'ecran, manipuler une variable, ouvrir une Alert()
param ( [string] $You = $(read-host "Enter your first name") )
write-host "$You so totally rocks"

--Cr�� une variable avec la date du jour, cr�� tableau de valeur et affiche les donn�es su tableau
--$_ et une variable qui renvoie le dernier objet manipul�
$currdate = (Get-Date -Format "yyyyMMdd hhmmtt")
$servers = @("ROGUE", "CEREBRO")
$servers | ForEach-Object {Write-Host $currdate $_}


--remonter d'un cran le chemin
cd ..
cd DEFAULT                -- entr�e dans le dossier DEFAULT
$PWD                      -- afficher l'emplacement dans lequel nous sommes
ls                        -- afficher la liste des dossier
--Connaitre l'emplacement
$PWD


-- Sortir la liste des services avec le mot SQL et la trier
Get-Service -name "*SQL*" | Select-Object ServiceName, Status, DisplayName | Sort-Object Status -Descending


-- List
$lList = @("RAN_ATOFFICE", "NES_ATOFFICE", "NEO_ATOFFICE") 	# cr�e une liste
Write-Host $lList[0]						# renvoie RAN_ATOFFICE
ForEach {}

-- Mettre le script dans un fichier nomm� .ps1
-- Executer � partir de PowerShell
PS C:\> C:\Scripts\Get-RunningServices.ps1 -Base RAN_ATOFFICE

-- Voir l'aide dans une Pop-Up
Get-Help Get-ChildItem -ShowWindow
-- Voir l'aide sur le site Microsoft
Get-Help Get-ChildItem -Online

---------------------------------------------------
---------------------------------------------------
-------------Exemples Codes------------------------
---------------------------------------------------
---------------------------------------------------

-----Parametres du server
$instance="localhost"
$server=New-Object -TypeName Microsoft.SqlServer.Management.Smo.Server -ArgumentList $instance
$server | Select Name, Version, Status, ConnectionContext, ComputerNamePhysicalNetBios

-----Infos sur lordinateur
$instance="localhost"
Get-WmiObject -Class Win32_ComputerSystem -ComputerName $instance
Select-Object Name, Domain, NumberOfProcessors, NumberOfLogicalProcessors | Format-List

-----Infos sur l'UC
$instance="localhost"
Get-WmiObject -Class Win32_Processor -ComputerName $instance | Measure-Object -Property LoadPercentage -Average

-----Quel types de propri�t� en rapport avec la Memoire y a t'il d'accessible sur le serveur
$instance="localhost"
Get-WmiObject -Class Win32_OperatingSystem -ComputerName $instance | Get-Member -MemberType Property | Where-Object {$_.Name -like "*mem*"} | Select-Object Name

-----Memoire de l'ordinateur, memoire libre, Taux de memoire utilis�e
$instance = "localhost"
Get-WmiObject -Class Win32_OperatingSystem -ComputerName $instance |
Select-Object @{Name="TotalVisibleMemorySize (GB)";Expression={"{0:N1}" -f (($_.TotalVisibleMemorySize)/1024/1024)}}
            , @{Name="FreePhysicalMemory (GB)";Expression={"{0:N1}" -f (($_.FreePhysicalMemory)/1024/1024)}}
            , @{Name="MemoryUsage %";Expression={ "{0:N2}" -f ((($_.TotalVisibleMemorySize - $_.FreePhysicalMemory)*100)/ $_.TotalVisibleMemorySize) }} |
Format-List


-------------------Administration de SQL Server---------
-- A surveiller:
--	Processeur usage
--	Available disks and their usage
--	Available memory and their usage
--	Network

-- Fichier de paramètres de PowerShell
$profile

-- Caracteristiques du server
Get-WmiObject -Class Win32_ComputerSystem -ComputerName localhost | Select-Object Name,Domain,NumberOfProcessors,NumberOfLogicalProcessors |Format-List

-- Nbre de processeurs en utilisation et Nbre de processus en cours
Get-WmiObject -Class Win32_Processor -ComputerName localhost | Measure-Object -Property LoadPercentage �Average

-- Type de memoire sur lequel la class peut agir
Get-WmiObject -Class Win32_OperatingSystem -ComputerName localhost | Get-Member -MemberType Property | Where-Object Name -Like "*Mem*" | Select-Object Name

-- Utilisation de la memoire
Get-WmiObject -Class Win32_OperatingSystem -ComputerName localhost
| Select-Object   @{Name="TotalVisibleMemorySize (GB)"; Expression={"{0:N1}" -f (($_.TotalVisibleMemorySize)/1024/1024)}}
		, @{Name="FreePhysicalMemory (GB)";Expression={"{0:N1}" -f (($_.FreePhysicalMemory)/1024/1024)}}
		, @{Name="MemoryUsage %";Expression={ "{0:N2}" -f ((($_.TotalVisibleMemorySize - $_.FreePhysicalMemory)*100)/ $_.TotalVisibleMemorySize) }}
| Format-List

-- Disque durs - Utilisation
#current server name
$servername = "localhost"
Get-WmiObject -Class Win32_LogicalDisk -ComputerName $servername | Select-Object @{Name="DeviceID";Expression={$_.DeviceID}}, @{Name="DriveType"; Expression={switch ($_.DriveType)
    {
        0 {"Unknown"}
        1 {"No Root Directory"}
        2 {"Removable Disk"}
        3 {"Local Disk"}
        4 {"Network Drive"}
        5 {"Compact Disc"}
        6 {"RAM Disk"}
    }};
}	, @{Name="Size (GB)";Expression={"{0:N1}" -f($_.Size/1GB)}}
	, @{Name="Free Space (GB)";Expression={"{0:N1}" -f($_.FreeSpace/1GB)}}
	, @{Name="Free Space (%)";Expression={if ($_.Size -gt 0) {"{0:P0}" -f($_.FreeSpace/$_.Size)} else {0}}}
| Format-Table -AutoSize

-- Disque dur local
Get-WmiObject -Class Win32_LogicalDisk �Filter "DriveType=3" -ComputerName localhost

-- Caracteristiques réseau du PC
Get-WmiObject -Class Win32_NetworkAdapterConfiguration -ComputerName localhost -Filter IPEnabled=True | Select-Object Description, DHCPEnabled, IPEnabled, IPAddress, MACAddress

-- Caracteristiques du systeme local
Get-WmiObject -Class Win32_OperatingSystem -ComputerName localhost | Select-Object CSName, Caption, ServicePackMajorVersion, ServicePackMinorVersion | Format-List

-- Liste des mise à jour du systeme
Get-WmiObject -Class Win32_QuickFixEngineering -ComputerName localhost | Sort-Object -Property InstalledOn -Descending | Format-Table –AutoSize

-- Liste des instances sur un server
$managedComputer = New-Object "Microsoft.SqlServer.Management.Smo.Wmi.ManagedComputer" localhost
$managedComputer.ServerInstances | Select-Object Name, State, ServerProtocols, Urn | Format-List

-- Liste des services SQL SERVER
$managedComputer = New-Object "Microsoft.SqlServer.Management.Smo.Wmi.ManagedComputer" localhost
$managedComputer.Services | Select-Object Name, ServiceAccount, DisplayName | Format-Table -AutoSize

-- Log - Afficher les 5 dernières infos
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" localhost
$server.ReadErrorLog() | Select-Object LogDate, ProcessInfo, Text, HasErrors -Last 5 | Format-List
-- Log suite - Liste des erreurs
$server.ReadErrorLog() | Where-Object HasErrors -eq $true

-- Propriétés de l'instance - Affichage sur ecran
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" localhost
$server | Get-Member | Where-Object Name -ne "SystemMessages" | Where-Object MemberType -eq "Property" | Select-Object Name, @{Name="Value";Expression={$server.($_.Name)}} | Format-Table -AutoSize

-- Propriétés de l'instance - Exportation dans fichier csv
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" localhost
$folder = "C:\Temp_XE"
$currdate = Get-Date -Format "yyyy-MM-dd_hmmtt"
$filename = "localhost_$($currdate).csv"
$fullpath = Join-Path $folder $filename
$server | Get-Member | Where-Object Name -ne "SystemMessages" | Where-Object MemberType -eq "Property" | Select-Object Name, @{Name="Value";Expression={$server.($_.Name)}} | Export-Csv -Path $fullpath -NoTypeInformation

-- Liste des actions qu'il est possible d'effectuer sur les services
Get-Command -Name "*Service*" -CommandType "Cmdlet"

-- Arreter et relancer le service Agrent SQl
$servicename = "SQLSERVERAGENT"  #si pas instance par défaut alors nom d instance à la suite: SQLAgent$MSSQLSERVER
Stop-Service -Name $servicename
Start-Service -Name $servicename

-- Demmarer un service si il est arreté
$myService = "MonService"
$etatService = (get-service | Where-Object {$_.name -eq $myService } | select Status | ft -HideTableHeader) | Out-String
if ($etatService.trim() -eq "Stopped"){start-service -name $myService}

-- Retrouver le nom d'un service
Get-Service | Where-Object {$_.name -like "*SQL*"}

-- Manipulation d'un objets
$managedComputer = New-Object "Microsoft.SqlServer.Management.Smo.Wmi.ManagedComputer" "localhost"
$sqlservice = $managedComputer.Services | Where-Object Name -EQ "SQLSERVERAGENT"
$sqlservice.ServiceAccount

-- On peut modifier les propriétés du servers
-- Par exemple, changer le chemin de backup par défaut de l'instance
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" "localhost"
$server.BackupDirectory			#Afficher la propriété
$server.BackupDirectory = "c:\Data"	#Modifier la propriété
$server.Alter()

-- Voir la configuration du server SqlServer
$server.Settings

------- A la place de sp_configure
--  Autoriser la reconfiguration du server
$server.Configuration.XPCmdShellEnabled.ConfigValue = 1
$server.Configuration.Alter()
$server.Configuration.XPCmdShellEnabled

-- REconfigurer le niveau d'audit
$server.Settings.AuditLevel = [Microsoft.SqlServer.Management.Smo.AuditLevel]::All
$server.Settings.Alter()

--------------------Listing databases et Tables
-- Appel de l'objet server
$servername = "localhost"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
-- Gestion de la connexion - Utilisation de Credential
$server.ConnectionContext.LoginSecure=$false;
$credential = Get-Credential
$server.ConnectionContext.set_Login($credential.UserName)
$server.ConnectionContext.set_SecurePassword($credential.Password)
-- Sinon on peut se connecter en passant les paramètres de connexion
$dataSource = "localhost"
$username = "sa"
$database = "RAN_ATOFFICE"
$password = "admin"
$connectionString = "Server=$dataSource;uid=$username;
pwd=$password;Database=$database;Integrated Security=False"
$connection = New-Object System.Data.SqlClient.SqlConnection
$connection.ConnectionString = $connectionString

-- Nombre de bases
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$server.databases.Count

-- Liste de bases non système
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$server.Databases | Where-Object IsSystemObject -eq $false

-- Informations à propos des bases
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$result = @()		#création d un tableau
$server.Databases | Where-Object IsSystemObject -eq $false | ForEach-Object {
	$db = $_
	$object = [PSCustomObject] @{
		Name = $db.Name
		CreateDate = $db.CreateDate
		RecoveryModel = $db.RecoveryModel
		NumTables = $db.Tables.Count
		NumUsers = $db.Users.Count
		NumSP = $db.StoredProcedures.Count
		NumUDF = $db.UserDefinedFunctions.Count
		}
	$result += $object
}
$result | Format-Table -AutoSize

-- Toutes les propriétés de l'objet database de Server
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$server.Databases | Get-Member | Where-Object MemberType –eq "Property"
-- Toutes les méthodes
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$server.Databases | Get-Member | Where-Object MemberType –eq "Method"

-- Liste des FileGroup des bases
Import-Module sqlserver
$servername = "localhost"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$result = @()
$server.Databases | Where-Object IsSystemObject -eq $false | ForEach-Object {
	$db = $_
	$db.FileGroups | ForEach-Object {
		$fg = $_
		$fg.Files | ForEach-Object {
			$file = $_
			$object = [PSCustomObject] @{
				Database = $db.Name
				FileGroup = $fg.Name
				FileName = $file.FileName | Split-Path -Leaf
				"Size(MB)" = "{0:N2}" -f ($file.Size/1024)
				"UsedSpace(MB)" = "{0:N2}" -f ($file.UsedSpace/1MB)
				}
			$result += $object
			}
	}
	} $result | Format-Table -AutoSize

	-- Ajouter un FileGroup
	Import-Module sqlserver
	$servername = "localhost"
	$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
	$dbname = "TEST"
	$db = $server.Database[$dbname]
	$fg = New-Object "Microsoft.SqlServer.Management.Smo.Filegroup" $db, "FG1"
	$fg.Create()
	-- Ajouter un fichier
	$datafile = New-Object "Microsoft.SqlServer.Management.Smo.DataFile" $fg, "data4"
	$datafile.FileName = "C:\DATA\data4.ndf"
	$datafile.Create()
	-- Changer la taille d'un fichier
	$db = $server.Databases[$dbname]
	$fg = $db.FileGroups["FG1"]
	$file = $fg.Files["data4"]
	$file.Size = 2 * 1024 #2MB
	$file.Alter()


-----------------------------------PROCESSUS-------------
-- Liste des processus non-systeme donc SQLSERVER
Import-Module sqlserver
$servername = "localhost"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$server.EnumProcesses() | Where-Object IsSystem -eq $false | Select-Object Spid, Database, IsSystem, Login, Status, Cpu, MemUsage, Program | Format-Table -AutoSize
-- Pareil avec un order by DESC sur la consommation CPU
$server.EnumProcesses() | Where-Object IsSystem -eq $false | Select-Object Spid, Database, IsSystem, Login, Status, Cpu, MemUsage, Program | Sort-Object Cpu -descending | Format-Table -AutoSize
-- Pareil avec deux clause Where dont une sur la BDD
$server.EnumProcesses() | Where-Object {$_.IsSystem -eq $false -and $_.Database -eq "NEO_ATOFFICE"} | Select-Object Spid, Database, IsSystem, Login, Status, Cpu, MemUsage, Program | Sort-Object Cpu -descending | Format-Table -AutoSize
-- Arreter un PROCESSUS
$blockingSpid = 56
$server.KillProcess($blockingSpid)
-- Arreter tous les processus d'une base de données
$dbname = "RAN_ATOFFICE"
$server.KillAllProcesses($dbname)

----------------------------------Servers Features
-- Liste des accessoire (AlwaysOne, FileStream, Cluster, FullText, etc.)
Import-Module sqlserver
$servername = "localhost"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$server | Select-Object IsClustered, ClusterName, FilestreamLevel, IsFullTextInstalled, LinkedServers, IsHadrEnabled, AvailabilityGroups

----------------------------------Script des objets SQL SERVER
Import-Module sqlserver
$servername = "localhost"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$dbname = "RAN_ATOFFICE"
$db = $server.Databases[$dbname]
$script = New-Object "Microsoft.SqlServer.Management.Smo.Scripter" $server
$scriptOptions = New-Object "Microsoft.SqlServer.Management.Smo.ScriptingOptions"
$scriptOptions.AllowSystemObjects = $false
$scriptOptions.DriAll = $true
$scriptOptions.ToFileOnly = $true
$script.Options = $scriptOptions
$smoObjects = @()
$filename = "C:\temp_XE\$($dbname)_tables_export.sql"
$script.Options.FileName = $filename
$db.Tables | Where-Object IsSystemObject -eq $false | Foreach-Object {$smoObjects += $_}  #pour les procedures : $db.StoredProcedures
$script.Script($smoObjects)

-- Transferer les objets d'une base à une autre (script ou Data) - ScriptTransfer(), TransferData()
-- Voir http://msdn.microsoft.com/en-us/library/microsoft.sqlserver.management.smo.transfer.aspx
Import-Module sqlserver
$servername = "localhost"
$srv = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$dbname = "RAN_ATOFFICE"
$db = $srv.Databases[$dbname]
--Création d'une nouvelle base
$dbCopy = New-Object -TypeName Microsoft.SqlServer.Management.SMO.Database -argumentlist $srv, "RAN_ATOFFICE_COPY"
$dbCopy.Create()
-- Objet transfert et otpions
$xfr = New-Object -TypeName Microsoft.SqlServer.Management.SMO.Transfer -ArgumentList $db
$xfr.CopyAllTables = $true
$xfr.Options.WithDependencies = $true
$xfr.Options.ContinueScriptingOnError = $true
$xfr.DestinationDatabase = "RAN_ATOFFICE_COPY"
$xfr.DestinationServer = $srv.Name
$xfr.DestinationLoginSecure = $true
$xfr.CopySchema = $true
"Scripting Data Transfer"
#Script the transfer. Alternatively perform immediate data transfer with TransferData method.
$xfr.ScriptTransfer() #TransferData()

-----------------------------Création d'une base  de données
$dbCopy = New-Object -TypeName Microsoft.SqlServer.Management.SMO.Database -argumentlist $srv, "AdventureWorksCopy"
$dbCopy.Create()

-----------------------------Détachement de base de données
Import-Module sqlserver
$servername = "localhost"
$sourceserver = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$dbname = "RAN_ATOFFICE"
#$sourceserver | Get-Member | Where-Object MemberType –eq "Method"
#$sourceserver.EnumDetachedDatabaseFiles($mdf)
#$sourceserver.EnumDetachedLogFiles($mdf)
$sourceserver.DetachDatabase($dbname, $true, $true)
-----------------------------Attachement de base de données
Import-Module SQLSERVER -DisableNameChecking
$destinationname = "localhost"
$destinationserver = New-Object "Microsoft.SqlServer.Management.Smo.Server" $destinationname
#$destinationserver.Name
$dbname = "RAN_ATOFFICE"
$mdf = "C:\DATA\DATA RANBAXY\RAN_ATOFFICE.mdf"
#this is where we will store all primary, secondary and log file information
$files = New-Object System.Collections.Specialized.StringCollection
#assuming we need the attach process to point to a different path than what s stored in the mdf
#we can specify a data path, and rebuild all the paths before we store in our collection
$datapath = "C:\DATA\DATA RANBAXY"
#collect all data file information
$sourceserver.EnumDetachedDatabaseFiles($mdf) | ForEach-Object { #update location of file to new path
$newfile = Join-Path $datapath (Split-Path $_ -Leaf)
$files.Add($newfile)
}
#collect all log file information
$destinationserver.EnumDetachedLogFiles($mdf) | ForEach-Object { #update location of file to new path
$newfile = Join-Path $datapath (Split-Path $_ -Leaf)
$files.Add($newfile)
}
$destinationserver.AttachDatabase($dbname, $files)


-- Information sur les fichiers d'une base de données
$srv = new-Object Microsoft.SqlServer.Management.Smo.Server("(local)")
$db = New-Object Microsoft.SqlServer.Management.Smo.Database
$db = $srv.Databases.Item("RAN_ATOFFICE")
#$db | Get-Member -MemberType Property | Where-Object {$_.Name -like "*file*"}
Foreach ($lf in $db.LogFiles)
{
   Write-Host "     [LOG] Fichier:"$lf.FileName, " Taille:"$lf.Length, " Nom:"$lf.Name
}
Foreach ($fg in $db.FileGroups)
{
    #$fg | Get-Member -MemberType Property
   Write-Host "     [DATA] Fichier:"$fg.Files, " Taille:"$fg.Length, " Nom:"$fg.Name
   Foreach ($f in $fg.Files){Write-Host "          [FICHIER] Nom:" $f.name, " Fichier:"$f.FileName, " Taille:"$f.Size}
}


-- Connaitre les méthodes d'un objet
$sourceserver | Get-Member | Where-Object MemberType –eq "Method"
-- Connaitre les propriétés d'un objet
$sourceserver | Get-Member | Where-Object MemberType –eq "Property"


------------------------------------BACKUP-------------
--Options à disposition
Get-Help Backup-SqlDatabase
-- BACKUP complete
Import-Module sqlserver
$servername = "localhost"
#$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$dbname = "RAN_ATOFFICE"
$currdate = Get-Date -Format yyyyMMddHHmmss
$backupfolder = "C:\DATA\BKP"
#generate backup file path and name
$fullbackupfilename = "$($dbname)_Full_$($currdate).bak"
$fullbackupfile = Join-Path $backupfolder $fullbackupfilename
#example filename that gets generated is: C:\DATA\BKP\Chinook_Full_20141023235306.bak
Backup-SqlDatabase -ServerInstance $servername -Database $dbname -BackupFile $fullbackupfile -Checksum -Initialize -BackupSetName "$dbname Full Backup"
Write-Output "Database has been backed up $fullbackupfile"

-- BackUp differentielle
Import-Module sqlserver
$servername = "localhost"
$dbname = "RAN_ATOFFICE"
$currdate = Get-Date -Format yyyyMMddHHmmss
$backupfolder = "C:\DATA\BKP"
$diffbackupfilename = "$($dbname)_Diff_$($currdate).bak"
$diffbackupfile = Join-Path $backupfolder $diffbackupfilename
Backup-SqlDatabase -ServerInstance $servername -Database $dbname -BackupFile $diffbackupfile -Incremental -Checksum -Initialize -BackupSetName "$dbname Diff Backup"
Write-Output "Database has been backed up $diffbackupfile"

--BackUp de journal de transactions
Import-Module sqlserver
$servername = "localhost"
$dbname = "RAN_ATOFFICE"
$currdate = Get-Date -Format yyyyMMddHHmmss
$backupfolder = "C:\DATA\BKP"
$logbackupfilename = "$($dbname)_Log_$($currdate).trn"
$logbackupfile = Join-Path $backupfolder $logbackupfilename
Backup-SqlDatabase -ServerInstance $servername -Database $dbname -BackupFile $logbackupfile -BackupAction Log -Checksum -Initialize -BackupSetName "$dbname Txn Backup"
# on veut juste connaitre le script:
#Backup-SqlDatabase -ServerInstance $servername -Database $dbname -BackupFile $logbackupfile -BackupAction Log -Checksum -Initialize -BackupSetName "$dbname Txn Backup" -Script
Write-Output "Database has been backed up $logbackupfile"

-- Lire les fichier de BackUp
Import-Module sqlserver
#current server name
$servername = "localhost"
#$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$dbname = "RAN_ATOFFICE"
$restore = New-Object "Microsoft.SqlServer.Management.Smo.Restore"
$backupfile = "C:\DATA\BKP\RAN_ATOFFICE_Log_20171214115050.trn"
$restore.Devices.AddDevice($backupfile,[Microsoft.SqlServer.Management.Smo.DeviceType]::File)
$restore.ReadFileList($server) | Select Type, LogicalName, PhysicalName, FileGroupName, Size
$restore.ReadBackupHeader($server)
$restore.ReadMediaHeader($server)

----------------------------Restore
--Options à disposition
Get-Help Restore-SqlDatabase

-- Mettre la base en SINGLE USER
$srv = new-Object Microsoft.SqlServer.Management.Smo.Server("(local)")
$db = New-Object Microsoft.SqlServer.Management.Smo.Database
$db = $srv.Databases.Item("RAN_ATOFFICE")
$db.useraccess = "Single"
#$db.DatabaseUserAccess = "Multiple"
$db.alter()



-- Restore de FULL, puis de DIFF et enfin des LOG. NORECOVERY pour les deux premiers
Import-Module sqlserver
#current server name
$servername = "localhost"
$backupfile = "C:\DATA\BKP\RAN_ATOFFICE_Full_20171214114750.bak"
Restore-SqlDatabase -Database $dbname -ReplaceDatabase -ServerInstance $servername -BackupFile $backupfile -NoRecovery

$backupfile = "C:\DATA\BKP\RAN_ATOFFICE_Diff_20171214115028.bak"
Restore-SqlDatabase -Database $dbname -ReplaceDatabase -ServerInstance$servername -BackupFile $backupfile -NoRecovery

$backupfile = "C:\DATA\BKP\RAN_ATOFFICE_Log_20171214115050.trn"
Restore-SqlDatabase -Database $dbname -ReplaceDatabase -ServerInstance $servername -BackupFile $backupfile
-ToPointInTime "2017-13-14 10:58:42"

----------------------------- INDEX --------------
-- Information sur les index: Type, Nbre pages, Taux de fragmentation, espace utilisé
Import-Module SQLSERVER
$servername = "localhost"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$dbname = "NEO_ATOFFICE"
$result = @()
$db = $server.Databases[$dbname]
$db.Tables | ForEach-Object {
    $table = $_
    $table.Indexes | Sort-Object -Property Name | ForEach-Object {
        $index = $_
        $frag = $index.EnumFragmentation()
        $object = [PSCustomObject] @{
            Table = $table.Name
            Index = $index.Name
            Type = $frag.IndexType
            Pages = $frag.Pages
            "AvgFragmentation %" = "{0:N2}" -f ($frag.AverageFragmentation)
            "SpaceUsed(KB)" = $index.SpaceUsed
            }
        $result += $object
        }
    }
$result | Format-Table

-- Reorganisation et reconstruction d'index en fonction de leurs fragmentation
-- fragmentation entre 10 et 30 plus de 1000 pages
Import-Module SQLSERVER
$servername = "localhost"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$dbname = "NEO_ATOFFICE"
$result = @()
$db = $server.Databases[$dbname]
$db.Tables | ForEach-Object {
    $table = $_
    $table.Indexes | Sort-Object -Property Name | ForEach-Object {
        $index = $_
        $indexFrag = $index.EnumFragmentation()
            #$indexFrag is an object resulting from EnumFragmentation()
            if ($indexFrag.AverageFragmentation -ge 10 -and $indexFrag.AverageFragmentation -le 30 -and $indexFrag.Pages -ge 1000)
            {
                $index.Reorganize()
            }
            elseif ($indexFrag.AverageFragmentation -ge 30 -and
            $indexFrag.Pages -ge 1000)
            {
                $index.Rebuild()
            }            }
    }
$result | Format-Table

---------------------- USERS, LOGINS
-- Liste des LOGINS
Import-Module SQLSERVER
$server = "localhost"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$result = @()
# Si je veux connaitre les propriétés de Login
# $server.Logins | Get-Member -MemberType Property
$server.Logins | Where-Object IsSystemObject -EQ $false | ForEach-Object {
	$login = $_
	$object = [pscustomobject] @{
		Login = $login.Name
		LoginType = $login.LoginType
		CreateDate = $login.CreateDate
		ServerRoles = $login.ListMembers()
		}
		$result += $object
	}
$result | Format-Table -AutoSize

-- Liste des users des bases
Import-Module SQLSERVER
$servername = "localhost"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$result = @()
$server.Databases | Where-Object IsSystemObject -EQ $false | ForEach-Object {
	$db = $_
	$db.Users | Where-Object IsSystemObject -eq $false | ForEach-Object {
		$dbuser = $_
		$object = [PSCustomObject] @{
			Database = $db.Name
			DBUser = $dbuser.Name
			Orphaned = if ($dbUser.UserType -eq "NoLogin"){"Yes"} else {"No"}
			Login = $dbuser.Login
			LoginType = $dbUser.LoginType
			}
			$result += $object
		}
	}
$result | Format-Table -AutoSize

-- Liste des logins et leurs droits
$servername = "localhost"
$servername = "localhost"
$dbname = "NEO_ATOFFICE"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$result = @()
# Pripriétés de User
# $server.Databases.Users | Get-Member -MemberType Property
$server.Databases | Where-Object IsSystemObject -EQ $false | Where-Object Name –eq $dbname | ForEach-Object {
    $db = $_
    $db.Users | Where-Object IsSystemObject -eq $false | ForEach-Object {
        $dbuser = $_
        $object = [PSCustomObject] @{
            Database = $db.Name
            DBUser = $dbuser.Name
            Orphaned = if ($dbUser.UserType -eq "NoLogin"){"Yes"} else {"No"}
            Login = $dbuser.Login
            LoginType = $dbUser.LoginType
            DBRoles = $dbuser.EnumRoles()
            ObjectPermissions = ($db.EnumObjectPermissions($dbuser.Name) | SELECT @{N="P";E={$_.ObjectName + " " + $_.PermissionState + " " + $_.PermissionType }} )
            }
        $result += $object
    }
}
$result | Format-List

-- Création d'un login
Import-Module SQLSERVER
$servername = "(local)"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$loginname = "TestLogin"
#for this example, we will check if login exists and if it does we will drop it
if ($server.Logins.Contains($loginname)) {$server.Logins[$loginname].Drop()}
$login = New-Object "Microsoft.SqlServer.Management.Smo.Login" $server, $loginname
$login.LoginType = [Microsoft.SqlServer.Management.Smo.LoginType]::SqlLogin
$login.PasswordExpirationEnabled = $false
#prompt for password
$password = Read-Host "Password: " -AsSecureString
$login.PasswordPolicyEnforced = $false
$login.Create($password)
-- Ajouter un role
#add to server roles
$loginname = "TestLogin"
$server.Logins[$loginname].AddToRole("dbcreator")

-- Création d'un User
Import-Module SQLSERVER
$servername = "(local)"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$dbname = "RAN_ATOFFICE"
$dbusername = "TestUser"
$loginname = "TestLogin"
$db = $server.Databases[$dbname]
if ($db.Users.Contains($dbusername)){$db.Users[$dbusername].Drop()}
$dbuser = New-Object "Microsoft.SqlServer.Management.Smo.User" $db, $dbusername
$dbuser.Login = $loginname
$dbuser.Create()
#add database role
$db.Roles["db_datareader"].AddMember($dbuser.Name)
-- Ajouter des droits à l'utilisateur sur la table CLIENT
Import-Module SQLSERVER
$servername = "(local)"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$dbname = "RAN_ATOFFICE"
$dbusername = "TestUser"
$loginname = "TestLogin"
$db = $server.Databases[$dbname]
$dbuser = New-Object "Microsoft.SqlServer.Management.Smo.User" $db, $dbusername
$dbuser.Login = $loginname
#initial permission is View Definition
$permissionset = New-Object "Microsoft.SqlServer.Management.Smo.ObjectPermissionSet"([Microsoft.SqlServer.Management.Smo.ObjectPermission]::ViewDefinition)
#add additional permission: Alter
$permissionset.Add([Microsoft.SqlServer.Management.Smo.ObjectPermission]::Alter)
#add permission set to the database view vwAlbums
$db.Tables["CLIENT"].Grant($permissionset, $dbuser.Name)

---------------- Policy
-- List des  policies mis en place
Import-Module SQLSERVER
Set-Location "SQLSERVER:\SQLPolicy\localhost"
Set-Location "DEFAULT"
dir
-- On peut se délacer dedans
Set-Location "Policies"
dir
--  Evaluer une stratégie
Get-Item "test" | Invoke-PolicyEvaluation –TargetServerName "localhost"

------------------ Jobs
-- Liste des Jobs
Import-Module SQLSERVER
$servername = "(local)"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
#$server.JobServer | Select-Object *
$result = @()
# Propriétés de JobSteps
#$server.JobServer.Jobs.JobSteps | Get-Member -MemberType Property
$server.JobServer.Jobs | Foreach-Object {
    $job = $_
    $job.JobSteps | ForEach-Object {
        $jobstep = $_
        $object = [PSCustomObject] @{
            Name = $job.Name
            LastRunDate = $job.LastRunDate
            LastRunOutcome = $job.LastRunOutcome
            Step = $jobstep.Name
            LastStepOutcome = $jobstep.LastRunOutcome
            }
        $result += $object
    }
}
$result | Format-Table
# $result | Format-List

------------------ Requetage classique sur SqlServer
--------------------------- Avec  Invoke-Sqlcmd
-- Exemple
Import-Module SQLSERVER
$servername = "localhost"
$database = "RAN_ATOFFICE"
#query inside a here-string
$query = @"
SELECT
TOP 10 *
FROM
dbo.CLIENT
"@
#if not providing username and password then uses current context
Invoke-Sqlcmd -ServerInstance $servername -Database $database -Query $query | Format-Table
# Sortie dans un fichier
Invoke-Sqlcmd -ServerInstance $servername -Database $database -Query $query | Out-File "C:\Temp_XE\results.rpt"
# Passer user et mot de passe
Invoke-Sqlcmd -Username "sa" -Password "admin" -ServerInstance $servername -Database $database -Query $query | Format-Table | Out-File "C:\temp_XE\results.rpt"
# Sortie dans un CSV  - Si on ne veut pas des entetes : -NoTypeInformation
Invoke-Sqlcmd -Username "sa" -Password "admin" -ServerInstance $servername -Database $database -Query $query | Export-Csv –NoTypeInformation –Path "C:\Temp\results.csv"

-- Exécuter une requête
$servername = "(local)"
$database = "RAN_ATOFFICE"
$query = "select top 10 RS from CLIENT"
Invoke-Sqlcmd -ServerInstance $servername -Database $database -Query $query

-- Lancer une requête écrite dans un fichier
Import-Module SQLSERVER
$variables = "TOP = 10"
$servername = "localhost"
$database = "RAN_ATOFFICE"
# texte dans fichier sql.txt : select top $(TOP) NOM, RS, VILLE from CLIENT order by IDCLIENT
$file = "C:\Temp_XE\sql.txt"  # La requête est là
Invoke-Sqlcmd -Username "sa" -Password "admin" -ServerInstance $servername -Database $database -InputFile $file -Variable $variables

-- Lancer une requête sur plusieurs servers
#get a list of databases from a file
Import-Module SQLSERVER
$servername = "localhost"
$file = "C:\Temp_XE\servers.txt"	# dans le fichier il y a une liste de bases
$query = "Select top 3 NOM, RS, VILLE from CLIENT"
#execute query to multiple databases
Get-Content $file | ForEach-Object {Invoke-Sqlcmd -ServerInstance $servername -Database $_ -Query $query}

-- Foemater le résultat d'une requête
Import-Module SQLSERVER
$servername = "localhost"
# texte dans fichier sql.txt : select top $(TOP) NOM, RS, VILLE from CLIENT order by IDCLIENT
$file = "C:\Temp_XE\sql.txt"   # La requête est là
$variables = "TOP = 10"
$results = Invoke-Sqlcmd -ServerInstance $servername -Database $database -InputFile $file -Variable $variables
#$results | Get-Member # Voir les méthodes et les champs utilisables
$results | ForEach-Object { #get current row
    $row = $_
    "Son nom est " + $row.NOM + ", il habite à " + $row.VILLE
}

------------SQLCMD exécutable à partir de cmd classique
-- Voir les paramètres à disposition
	sqlcmd /?
-- lancer sqlcmd en se connectant à une base spécifique
	sqlcmd -s (local) -d RAN_ATOFFICE -U sa -P admin
	$servername = "(local)"
	$database = "RAN_ATOFFICE"
	$query = "select top 10 RS from CLIENT"
	Invoke-Sqlcmd -ServerInstance $servername -Database $database -Query $query

-- Voir la défragmentation des index
Import-Module SQLSERVER
$servername = "(local)"
$database = "RAN_ATOFFICE"
$query = @"
    SELECT
        OBJECT_NAME(phys_stats.OBJECT_ID) AS [Object], idx.name AS [Index Name], phys_stats.index_type_desc [Index Type]
        , phys_stats.avg_fragmentation_in_percent [Fragmentation %], phys_stats.page_count [# Pages]
    FROM sys.dm_db_index_physical_stats(DB_ID(),NULL, NULL, NULL, N'LIMITED') AS phys_stats
    INNER JOIN sys.indexes AS idx WITH (NOLOCK) ON phys_stats.[object_id] = idx.[object_id] AND phys_stats.index_id = idx.index_id
    WHERE phys_stats.database_id = DB_ID()
    ORDER BY phys_stats.avg_fragmentation_in_percent DESC;
"@
#Invoke-Sqlcmd -ServerInstance $servername -Database $database -Query $query | Format-Table -AutoSize
Invoke-Sqlcmd -ServerInstance $servername -Database $database -Query $query | Format-Table -AutoSize | Out-File "C:\Temp_XE\defrag.txt"
# Convertir en html
#Invoke-Sqlcmd -ServerInstance $servername -Database $database -Query $query | ConvertTo-HTML | Out-File "C:\Temp_XE\defrag.htm"
#Ouvrir le fichier html dans la foulée: Invoke-Expression C:\Temp_XE\defrag.htm
# Convertir en csv
#Invoke-Sqlcmd -ServerInstance $servername -Database $database -Query $query | Export-Csv "C:\Temp_XE\defrag.csv"

-- BACKUP de bases à l'aide de Invoke
Import-Module SQLSERVER
$servername = "(local)"
$database = "RAN_ATOFFICE"
$query = @"
    BACKUP DATABASE RAN_ATOFFICE TO DISK='C:\DATA\BKP\RAN_ATOFFICEbyPowershell.bak' WITH FORMAT, COMPRESSION
"@
Invoke-Sqlcmd -ServerInstance $servername -Database $database -Query $query

---------------Surveillance d'un serveur
-- Envoi d'un mail
Send-MailMessage -To "Manager 1 <Manager1@xyz.com>", "Manager2 <Manager2@xyz.com>" -CC "Manager 3 <Manager3@xyz.com>"
	-From "Reports Admin <Reportadmin@xyx.com>" -SMTPServer smtp1.xyz.com -Credentials (Get-Credential)
	-Subject “Daily report” -Body “This is a daily report of servers uptime” -Attachments “c:\temp\server1-uptime-report.txt”, “c:\temp\server2-uptime-report.txt”

-- On peut écrire dans le log
 Write-EventLog ...

-- Lire le journal d'erreurs
Import-Module SQLSERVER
$instance = "(local)"
$server=New-Object -TypeName Microsoft.SqlServer.Management.Smo.Server -ArgumentList $instance
$content = ($server.ReadErrorLog() | Where-Object {$_.Text -like "*failed*" -or $_.Text -like "*error*"})

-- Envoyer un mail suite à une erreur
Import-Module SQLSERVER
#current server name
$servername = "localhost"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
#get the last 10 error entries, and convert to HTML
$content = ($server.ReadErrorLog() | Where-Object {$_.Text -like "*failed*" -or $_.Text -like "*error*" -or $_.HasErrors -eq $true} | Select-Object LogDate, ProcessInfo, Text, HasErrors -Last 10 | ConvertTo-Html)
#email settings
$currdate = Get-Date -Format "yyyy-MM-dd hmmtt"
$smtp = "smtp.nomadvantage.com"
$to = "DBA <sdurand@nomadvantage.com>"
$from = "DBMail <sdurand@nomadvantage.com>"
$subject = "Last 10 Errors as of $currdate"
#send the email
Send-MailMessage -SmtpServer $smtp -To $to -from $from -Subject $subject -Body "$($content)" -BodyAsHtml

-- 
