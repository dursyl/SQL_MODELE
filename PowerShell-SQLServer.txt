--------------------Premier pas-------
    -- On  peut faire aussi comme �a:
	Import-Module SQLSERVER
        CD SQLSERVER:\sql\localhost\DEFAULT


    --Ces SnapIn doit exister si je veux utiliser SQLSERVER sur PowerShell
        Get-PSSnapin SqlServerCmdLetSnapin100
        Get-PSSnapin SqlServerProviderSnapin100
    --Sinon il faut les ajouter   (sur 2012 pas besoin de �a, on doit  charger SQLPS)
        Add-PSSnapin SqlServerCmdLetSnapin100
        Add-PSSnapin SqlServerProviderSnapin100

---------------------------------------

    --Se placer dans le serveur SQL
        Set-Location SQLSERVER:\SQL\localhost

    --Requ�te
        Invoke-Sqlcmd -Query "SELECT DB_NAME() as [Database]"

    --Requ�te T-SQL
        CD SQLSERVER:\sql\localhost\DEFAULT
        Invoke-sqlcmd -Database TV_ATOFFICE -Query "select * from USR" | Format-Table

    --Requ�te T-SQL - Sortie CSV
        CD SQLSERVER:\sql\localhost\DEFAULT
        Invoke-sqlcmd -Database TV_ATOFFICE -Query "select * from USR" | Export-CSV c:\TV_USER.csv  -encoding "unicode"

    --Cr�er dossier
        md c:\test
    --cr�er fichier
        fsutil file createnew C:\test\mynewfile.txt 1000

    --Divers stats du serveur envoy�es dans un fichier
        ipconfig /all >C:\test\tshoot.txt
        route print >C:\test\tshoot.txt
        hostname >C:\test\tshoot.txt
        net statistics workstation >C:\test\tshoot.txt
    --Ouverture fichier texte
        notepad C:\test\tshoot.txt
    --Passer le noms de tables d'une base de donn�es dans un fichier texte
      --Lancer PowerShell en cliquant droit sur une Base de donn�es (SSMS)
        dir -Name >C:\test\TableNes.txt







-----------------------------------------------

#https://www.mssqltips.com/sqlservertip/1745/using-powershell-with-sql-server-management-objects-smo/
--recuperer des scripts : https://github.com/MikeFal

--PLusieurs lignes de commentaires
<#
#>

--Voir les Provider � disposition (on doit voir SQLServer apparaitre dans la liste
Get-PSProvider

--Voir les DRIVE (connecteurs disque c:\ d:\)
Get-PSDrive

--Voir les enfants du provider dans lequel on est
Get-ChildItem

--Si Dans Get-PSDrive: SQLSERVER apparait alors je peux naviguer dans SQL Server
  -- Si je fait "dir" ici alors j'ai tout le parametrage de mon serveur
SQLSERVER:\SQL\DELLV-SD\Default

--Ces SnapIn doit exister si je veux utiliser SQLSERVER sur PowerShell
Get-PSSnapin SqlServerCmdLetSnapin100
Get-PSSnapin SqlServerProviderSnapin100
--Sinon il faut les ajouter   (sur 2012 pas besoin de �a, on doit  charger SQLPS)
Add-PSSnapin SqlServerCmdLetSnapin100
Add-PSSnapin SqlServerProviderSnapin100

--Utiliser les commandes relatives au module SQL Server
Get-Command �Module *SQL*
Get-Command �Name *SQL*

--Voir les propri�t�s d'un objet � partir de son type
$message = "Hello World!"
$message | Get-Member

--Il existe une variable systeme pour Powershell: PSModulePath
$env:PSModulePath


--Version de PowerShell
$PSVersionTable

--Changer de version
Powershell.exe -Version 2

--Liste des CmdLet avec le mot Log
Get-Command -Name "*Log*"

--Help (aide) sur un CmdLet
Get-Help Get-Service

--Exemples
get-help Get-Service -examples

--Simple requ�te
sqlcmd -S localhost -d TV_ATOFFICE -U sa -P admin -Q "select getDate()"
Invoke-Sqlcmd -ServerInstance localhost -Database TV_ATOFFICE -Query "select GetDate()"

--Lecteur sur le PC
Get-PSDrive

--Allez voir dans le registre les infos li�es � Sql Server
cd "HKLM:\Software\Microsoft\Microsoft SQl Server"

--Afficher tous les cmdlet qui commence par Get-
Get-Command | Where-Object {$_.Name -like "Get-*"}

--Affiche les cmdlet qui commence par Format-
Get-Command Format-*

--Affiche les service qui concomme plus de 50 Mb sur le PC en les formatant sous forme de liste
Get-Process | Where-Object {$_.PrivateMemorySize -gt 50MB} | SELECT ProcessName, PrivateMemorySize, CPU | Format-List

--Exporter sur fichier CSV les servies qui consomme pmlus de 50 Mb sur le PC
Get-Process | Where-Object {$_.PrivateMemorySize -gt 50MB} | SELECT ProcessName, PrivateMemorySize, CPU | Export-CSV c:\process.csv

--Membres du cmdlet Get-Command
Get-Command | Get-Member

--Executer .ps1 - cganger la politiique de s�curit� pour cela
Set-executionPolicy RemoteSigned

--Redemaret le service SQL Server san connaitre le nom de l'instance complete
Get-Service | Where-Object {$_.Name -like "MSSQL$*"} | ReStart-Service -Force

--Service qui consome plus de 50 Mb sur le PC (gt->Greater Than, lt->Less Than, le->Less or Equal)
Get-Process | Where-Object {$_.PrivateMemorySize -gt 50MB}

--Se deplacer dansles dossier
Set-Location SQLSERVER:\SQL\localhost

--Ecrire sur l'ecran, manipuler une variable, ouvrir une Alert()
param ( [string] $You = $(read-host "Enter your first name") )
write-host "$You so totally rocks"

--Cr�� une variable avec la date du jour, cr�� tableau de valeur et affiche les donn�es su tableau
--$_ et une variable qui renvoie le dernier objet manipul�
$currdate = (Get-Date -Format "yyyyMMdd hhmmtt")
$servers = @("ROGUE", "CEREBRO")
$servers | ForEach-Object {Write-Host $currdate $_}


--remonter d'un cran le chemin
cd ..
cd DEFAULT                -- entr�e dans le dossier DEFAULT
$PWD                      -- afficher l'emplacement dans lequel nous sommes
ls                        -- afficher la liste des dossier
--Connaitre l'emplacement
$PWD


-- Sortir la liste des services avec le mot SQL et la trier
Get-Service -name "*SQL*" | Select-Object ServiceName, Status, DisplayName | Sort-Object Status -Descending


-- List
$lList = @("RAN_ATOFFICE", "NES_ATOFFICE", "NEO_ATOFFICE") 	# cr�e une liste
Write-Host $lList[0]						# renvoie RAN_ATOFFICE
ForEach {}

-- Mettre le script dans un fichier nomm� .ps1
-- Executer � partir de PowerShell
PS C:\> C:\Scripts\Get-RunningServices.ps1 -Base RAN_ATOFFICE

-- Voir l'aide dans une Pop-Up
Get-Help Get-ChildItem -ShowWindow
-- Voir l'aide sur le site Microsoft
Get-Help Get-ChildItem -Online

---------------------------------------------------
---------------------------------------------------
-------------Exemples Codes------------------------
---------------------------------------------------
---------------------------------------------------

-----Parametres du server
$instance="localhost"
$server=New-Object -TypeName Microsoft.SqlServer.Management.Smo.Server -ArgumentList $instance
$server | Select Name, Version, Status, ConnectionContext, ComputerNamePhysicalNetBios

-----Infos sur lordinateur
$instance="localhost"
Get-WmiObject -Class Win32_ComputerSystem -ComputerName $instance
Select-Object Name, Domain, NumberOfProcessors, NumberOfLogicalProcessors | Format-List

-----Infos sur l'UC
$instance="localhost"
Get-WmiObject -Class Win32_Processor -ComputerName $instance | Measure-Object -Property LoadPercentage -Average

-----Quel types de propri�t� en rapport avec la Memoire y a t'il d'accessible sur le serveur
$instance="localhost"
Get-WmiObject -Class Win32_OperatingSystem -ComputerName $instance | Get-Member -MemberType Property | Where-Object {$_.Name -like "*mem*"} | Select-Object Name

-----Memoire de l'ordinateur, memoire libre, Taux de memoire utilis�e
$instance = "localhost"
Get-WmiObject -Class Win32_OperatingSystem -ComputerName $instance |
Select-Object @{Name="TotalVisibleMemorySize (GB)";Expression={"{0:N1}" -f (($_.TotalVisibleMemorySize)/1024/1024)}}
            , @{Name="FreePhysicalMemory (GB)";Expression={"{0:N1}" -f (($_.FreePhysicalMemory)/1024/1024)}}
            , @{Name="MemoryUsage %";Expression={ "{0:N2}" -f ((($_.TotalVisibleMemorySize - $_.FreePhysicalMemory)*100)/ $_.TotalVisibleMemorySize) }} |
Format-List


-------------------Administration de SQL Server---------
-- A surveiller:
--	Processeur usage
--	Available disks and their usage
--	Available memory and their usage
--	Network

-- Fichier de paramètres de PowerShell
$profile

-- Caracteristiques du server
Get-WmiObject -Class Win32_ComputerSystem -ComputerName localhost | Select-Object Name,Domain,NumberOfProcessors,NumberOfLogicalProcessors |Format-List

-- Nbre de processeurs en utilisation et Nbre de processus en cours
Get-WmiObject -Class Win32_Processor -ComputerName localhost | Measure-Object -Property LoadPercentage �Average

-- Type de memoire sur lequel la class peut agir
Get-WmiObject -Class Win32_OperatingSystem -ComputerName localhost | Get-Member -MemberType Property | Where-Object Name -Like "*Mem*" | Select-Object Name

-- Utilisation de la memoire
Get-WmiObject -Class Win32_OperatingSystem -ComputerName localhost
| Select-Object   @{Name="TotalVisibleMemorySize (GB)"; Expression={"{0:N1}" -f (($_.TotalVisibleMemorySize)/1024/1024)}}
		, @{Name="FreePhysicalMemory (GB)";Expression={"{0:N1}" -f (($_.FreePhysicalMemory)/1024/1024)}}
		, @{Name="MemoryUsage %";Expression={ "{0:N2}" -f ((($_.TotalVisibleMemorySize - $_.FreePhysicalMemory)*100)/ $_.TotalVisibleMemorySize) }}
| Format-List

-- Disque durs - Utilisation
#current server name
$servername = "localhost"
Get-WmiObject -Class Win32_LogicalDisk -ComputerName $servername | Select-Object @{Name="DeviceID";Expression={$_.DeviceID}}, @{Name="DriveType"; Expression={switch ($_.DriveType)
    {
        0 {"Unknown"}
        1 {"No Root Directory"}
        2 {"Removable Disk"}
        3 {"Local Disk"}
        4 {"Network Drive"}
        5 {"Compact Disc"}
        6 {"RAM Disk"}
    }};
}	, @{Name="Size (GB)";Expression={"{0:N1}" -f($_.Size/1GB)}}
	, @{Name="Free Space (GB)";Expression={"{0:N1}" -f($_.FreeSpace/1GB)}}
	, @{Name="Free Space (%)";Expression={if ($_.Size -gt 0) {"{0:P0}" -f($_.FreeSpace/$_.Size)} else {0}}}
| Format-Table -AutoSize

-- Disque dur local
Get-WmiObject -Class Win32_LogicalDisk �Filter "DriveType=3" -ComputerName localhost

-- Caracteristiques réseau du PC
Get-WmiObject -Class Win32_NetworkAdapterConfiguration -ComputerName localhost -Filter IPEnabled=True | Select-Object Description, DHCPEnabled, IPEnabled, IPAddress, MACAddress

-- Caracteristiques du systeme local
Get-WmiObject -Class Win32_OperatingSystem -ComputerName localhost | Select-Object CSName, Caption, ServicePackMajorVersion, ServicePackMinorVersion | Format-List

-- Liste des mise à jour du systeme
Get-WmiObject -Class Win32_QuickFixEngineering -ComputerName localhost | Sort-Object -Property InstalledOn -Descending | Format-Table –AutoSize

-- Liste des instances sur un server
$managedComputer = New-Object "Microsoft.SqlServer.Management.Smo.Wmi.ManagedComputer" localhost
$managedComputer.ServerInstances | Select-Object Name, State, ServerProtocols, Urn | Format-List

-- Liste des services SQL SERVER
$managedComputer = New-Object "Microsoft.SqlServer.Management.Smo.Wmi.ManagedComputer" localhost
$managedComputer.Services | Select-Object Name, ServiceAccount, DisplayName | Format-Table -AutoSize

-- Log - Afficher les 5 dernières infos
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" localhost
$server.ReadErrorLog() | Select-Object LogDate, ProcessInfo, Text, HasErrors -Last 5 | Format-List
-- Log suite - Liste des erreurs
$server.ReadErrorLog() | Where-Object HasErrors -eq $true

-- Propriétés de l'instance - Affichage sur ecran
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" localhost
$server | Get-Member | Where-Object Name -ne "SystemMessages" | Where-Object MemberType -eq "Property" | Select-Object Name, @{Name="Value";Expression={$server.($_.Name)}} | Format-Table -AutoSize

-- Propriétés de l'instance - Exportation dans fichier csv
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" localhost
$folder = "C:\Temp_XE"
$currdate = Get-Date -Format "yyyy-MM-dd_hmmtt"
$filename = "localhost_$($currdate).csv"
$fullpath = Join-Path $folder $filename
$server | Get-Member | Where-Object Name -ne "SystemMessages" | Where-Object MemberType -eq "Property" | Select-Object Name, @{Name="Value";Expression={$server.($_.Name)}} | Export-Csv -Path $fullpath -NoTypeInformation

-- Liste des actions qu'il est possible d'effectuer sur les services
Get-Command -Name "*Service*" -CommandType "Cmdlet"

-- Arreter et relancer le service Agrent SQl
$servicename = "SQLSERVERAGENT"  #si pas instance par défaut alors nom d instance à la suite: SQLAgent$MSSQLSERVER
Stop-Service -Name $servicename
Start-Service -Name $servicename

-- Demmarer un service si il est arreté
$myService = "MonService"
$etatService = (get-service | Where-Object {$_.name -eq $myService } | select Status | ft -HideTableHeader) | Out-String
if ($etatService.trim() -eq "Stopped"){start-service -name $myService}

-- Retrouver le nom d'un service
Get-Service | Where-Object {$_.name -like "*SQL*"}

-- Manipulation d'un objets
$managedComputer = New-Object "Microsoft.SqlServer.Management.Smo.Wmi.ManagedComputer" "localhost"
$sqlservice = $managedComputer.Services | Where-Object Name -EQ "SQLSERVERAGENT"
$sqlservice.ServiceAccount

-- On peut modifier les propriétés du servers
-- Par exemple, changer le chemin de backup par défaut de l'instance
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" "localhost"
$server.BackupDirectory			#Afficher la propriété
$server.BackupDirectory = "c:\Data"	#Modifier la propriété
$server.Alter()

-- Voir la configuration du server SqlServer
$server.Settings

------- A la place de sp_configure
--  Autoriser la reconfiguration du server
$server.Configuration.XPCmdShellEnabled.ConfigValue = 1
$server.Configuration.Alter()
$server.Configuration.XPCmdShellEnabled

-- REconfigurer le niveau d'audit
$server.Settings.AuditLevel = [Microsoft.SqlServer.Management.Smo.AuditLevel]::All
$server.Settings.Alter()

--------------------Listing databases et Tables
-- Appel de l'objet server
$servername = "localhost"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
-- Gestion de la connexion - Utilisation de Credential
$server.ConnectionContext.LoginSecure=$false;
$credential = Get-Credential
$server.ConnectionContext.set_Login($credential.UserName)
$server.ConnectionContext.set_SecurePassword($credential.Password)
-- Sinon on peut se connecter en passant les paramètres de connexion
$dataSource = "localhost"
$username = "sa"
$database = "RAN_ATOFFICE"
$password = "admin"
$connectionString = "Server=$dataSource;uid=$username;
pwd=$password;Database=$database;Integrated Security=False"
$connection = New-Object System.Data.SqlClient.SqlConnection
$connection.ConnectionString = $connectionString

-- Nombre de bases
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$server.databases.Count

-- Liste de bases non système
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$server.Databases | Where-Object IsSystemObject -eq $false

-- Informations à propos des bases
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$result = @()		#création d un tableau
$server.Databases | Where-Object IsSystemObject -eq $false | ForEach-Object {
	$db = $_
	$object = [PSCustomObject] @{
		Name = $db.Name
		CreateDate = $db.CreateDate
		RecoveryModel = $db.RecoveryModel
		NumTables = $db.Tables.Count
		NumUsers = $db.Users.Count
		NumSP = $db.StoredProcedures.Count
		NumUDF = $db.UserDefinedFunctions.Count
		}
	$result += $object
}
$result | Format-Table -AutoSize

-- Toutes les propriétés de l'objet database de Server
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$server.Databases | Get-Member | Where-Object MemberType –eq "Property"
-- Toutes les méthodes
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$server.Databases | Get-Member | Where-Object MemberType –eq "Method"

-- Liste des FileGroup des bases
$servername = "localhost"
$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
$result = @()
$server.Databases | Where-Object IsSystemObject -eq $false | ForEach-Object {
	$db = $_
	$db.FileGroups | ForEach-Object {
		$fg = $_
		$fg.Files | ForEach-Object {
			$file = $_
			$object = [PSCustomObject] @{
				Database = $db.Name
				FileGroup = $fg.Name
				FileName = $file.FileName | Split-Path -Leaf
				"Size(MB)" = "{0:N2}" -f ($file.Size/1024)
				"UsedSpace(MB)" = "{0:N2}" -f ($file.UsedSpace/1MB)
				}
			$result += $object
			}
	}
	} $result | Format-Table -AutoSize

	-- Ajouter un FileGroup
	$servername = "localhost"
	$server = New-Object "Microsoft.SqlServer.Management.Smo.Server" $servername
	$dbname = "TEST"
	$db = $server.Database[$dbname]
	$fg = New-Object "Microsoft.SqlServer.Management.Smo.Filegroup" $db, "FG1"
	$fg.Create()
	-- Ajouter un fichier
	$datafile = New-Object "Microsoft.SqlServer.Management.Smo.DataFile" $fg, "data4"
	$datafile.FileName = "C:\DATA\data4.ndf"
	$datafile.Create()
	-- Changer la taille d'un fichier
	$db = $server.Databases[$dbname]
	$fg = $db.FileGroups["FG1"]
	$file = $fg.Files["data4"]
	$file.Size = 2 * 1024 #2MB
	$file.Alter()
